### 139. Java中的泛型是什么 ? 使用泛型的好处是什么?

  泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

  好处：

  1. 类型安全，提供编译期间的类型检测

  2. 前后兼容

  3. 泛化代码,代码可以更多的重复利用

  4. 性能较高，用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息，这些信息对java程序做进一步优化提供条件。



### 140，Java的泛型是如何工作的 ? 什么是类型擦除 ?如何工作？

  1. `类型检查`：在生成字节码之前提供类型检查

  2. `类型擦除`：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）

  3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决

  4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换

  **类型擦除**：

  所有类型参数都用他们的限定类型替换：

  比如T->Object ? extends BaseClass->BaseClass

  **如何工作**：

  泛型是通过`类型擦除`来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。
  例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。
  你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。
  根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。


### 141，你可以把`List<String>`传递给一个接受`List<Object>`参数的方法吗？

    对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以 List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。
    真这样做的话会导致编译错误。
    如果你再深一步考虑，你会发现Java这样做是有意义的，因为`List<Object>`可以存储任何类型的对象包括`String, Integer`等等，而List<String>却只能用来存储String s。
    ``` java
    List<Object> objectList;

    List<String> stringList;

    objectList = stringList; `//compilation error incompatible types`

    ```

### 142，如何阻止Java中的类型未检查的警告?

  如果你把`泛型`和`原始类型``混合`起来`使用`，例如下列代码，java 5的`javac编译器会产生类型未检查的警告`，例如
  ```java
  List<String> rawList = new ArrayList();
  ```
  注意: Hello.java使用了未检查或称为不安全的操作;

  这种警告可以使用`@SuppressWarnings(“unchecked”)`注解来屏蔽。

### 143，Java中List<Object>和原始类型List之间的区别?

  原始类型和带参数类型<Object>之间的主要区别是，在`编译时编译器不会对原始类型进行类型安全检查`，却会`对带参数的类型进行检查`，通过使用Object作为类型，可以告知编译器该方法`可以接受任何类型的对象`，比如String或Integer。

  这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把`List<String>`传递给接受 `List<Object>`的方法，因为会产生编译错误。

### 144，编写一段泛型程序来实现LRU缓存?

  对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，`LinkedHashMap`可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。

  LinkedHashMap提供了一个称为`removeEldestEntry()`的方法，该方法会被put() 和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。


### 145，Array中可以用泛型吗?

  这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道`Array事实上并不支持泛型`，这也是为什么Joshua Bloch在Effective Java一书中建议使用`List`来代替`Array`，因为List可以提供编译期的类型安全保证，而Array却不能。

### 146，如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?

  编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用`T, E or K,V`等被广泛认可的类型占位符。最简单的情况下，一个泛型方法可能会像这样：
  ```java
  public V put(K key, V value) {

      return cahe.put(key,value);

  }
  ```

### 147，C++模板和java泛型之间有何不同？

  java泛型实现根植于`“类型消除”`这一概念。当源代码被转换为Java虚拟机字节码时，这种技术会消除参数化类型。有了Java泛型，我们可以做的事情也并没有真正改变多少；他只是让代码变得漂亮些。鉴于此，Java泛型有时也被称为“语法糖”。

  这和 C++模板截然不同。在 C++中，模板本质上就是一套宏指令集，只是换了个名头，编译器会针对每种类型创建一份模板代码的副本。

  由于架构设计上的差异，Java泛型和C++模板有很多不同点：

  C++模板可以使用int等基本数据类型。Java则不行，必须转而使用Integer。

  在Java中，可以将模板的参数类型限定为某种特定类型。

  在C++中，类型参数可以实例化，但java不支持。

  在Java中，类型参数不能用于静态方法(?)和变量，因为它们会被不同类型参数指定的实例共享。在C++，这些类时不同的，因此类型参数可以用于静态方法和静态变量。

  在Java中，不管类型参数是什么，所有的实例变量都是同一类型。类型参数会在运行时被抹去。在C++中，类型参数不同，实例变量也不同。
