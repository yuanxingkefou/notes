### 41、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
  hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。
  根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。

### 42、字节流与字符流的区别

  要把一段二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为`IO流`，对应的抽象类为`OutputStream`和`InputStream`，不同的实现类就代表不同的输入和输出设备，它们都是`针对字节`进行操作的。

  计算机中的一切最终都是二进制的字节形式存在。对于经常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，Java专门提供了字符流包装类。

  底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。`字符流是字节流的包装`，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设备写入或读取字符串提供了一点点方便。

  `字符向字节转换`时，要`注意编码`的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。

### 43、什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。

  我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，
  例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输。

  但是，jre本身就提供了这种支持，我们可以调用`OutputStream`的`writeObject`方法来做，如果要让java帮我们做，要被传输的对象必须实现`serializable接口`，这样，javac编译时就会进行特殊处理，编译的类才可以被`writeObject`方法操作，这就是所谓的序列化。需要被序列化的类必须实现`Serializable接口`，该接口是一个`mini接口`，其中没有需要实现方法，`implements Serializable`只是为了标注该对象是可被序列化的。

  例如，在web开发中，如果对象被保存在了Session中，tomcat在重启时要把`Session对象序列化到硬盘`，这个对象就必须实现`Serializable接口`。如果对象要经过分布式系统进行网络传输，被传输的对象就必须实现Serializable接口。

### 44、描述一下JVM加载class文件的原理机制?

  JVM中类的装载是由`ClassLoader`和它的子类来实现的,`Java ClassLoader`是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。

### 45、heap和stack有什么区别。

  java的内存分为两类，一类是栈内存，一类是堆内存。

  栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的`局部变量`，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。

  堆是与栈作用不同的内存，一般用于存放不在当前方法栈中的那些数据，例如，使用`new`创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。

### 46、GC是什么?为什么要有GC?

  GC是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

### 47、垃圾回收的优点和原理。并考虑2种回收机制。

  Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。
  由于垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。

  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

  回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。

### 48、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

  对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
  通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。

  程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 49、Java 中，throw 和 throws 有什么区别

  throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个Exception，如：
  ```java
  throw new IllegalArgumentException("XXXXXXXXX");
  ```
  而`throws `的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。
  Java 中，任何未处理的受检查异常强制在 throws 子句中声明。

### 50，java中会存在内存泄漏吗，请简单描述。

  先解释什么是内存泄漏：所谓 **内存泄露** 就是 **指一个不再被程序使用的对象或变量一直被占据在内存中**。java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉。

  由于Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的。

  java中的内存泄露的情况：
  长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。
