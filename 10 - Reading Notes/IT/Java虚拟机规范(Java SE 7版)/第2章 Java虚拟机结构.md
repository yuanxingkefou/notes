### 2.1 class文件格式

### 2.2 数据类型

  Java虚拟机可以操作的数据类型可分为两类：**原始类型** 和 **引用类型**
  与之对应，也存在 **原始值** 和 **引用值** 两种类型的数值

### 2.3 原始类型与值
  Java虚拟机所支持的原始数据类型包括数值类型、boolean类型 和 returnAddress类型三类。
  其中数值类型分为 整数类型 浮点类型 两种

  整数类型：
    byte类型  8位
    short类型 16位
    int类型 32位
    long类型  64位
    char类型 16位
  浮点类型
    float类型
    double类型
  boolean类型
    true 和 false 默认为false
  returnAddress类型
    表示一条字节码指令的操作码（opcode）

#### 2.3.1 整数类型与整数型
  Java虚拟机的整数类型的取值范围如下：
  byte  -128  ~ 127  -27 ~ 27 -1
  short -32768 ~ 32767 -215 ~ 215 -1
  int -2147483648 ~ 2147483647 -231 ~ 231 - 1
  long -9223372036854775808 ~ 9223372036854775807 -263 ~ 263 - 1
  char  0 ~ 65535

#### 2.3.2 浮点类型、取值集合及浮点值
#### 2.3.3 returnAddress类型
#### 2.3.4 boolean类型

### 2.4 引用类型与值
  Java虚拟机有三种引用类型：类类型、数组类型、接口类型。

### 2.5 运行时数据区
  Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开水和结束而创建和销毁。
#### 2.5.1 PC寄存器
  Java虚拟机可以支持多条线程同时执行。每一条Java虚拟机线程都有自己的PC（program counter）寄存器。
  一条Java虚拟机线程只会执行一个方法的代码，这个正在被执行的方法被称为该线程的当前方法。
  如果这个方法不是native的，那Pc寄存器保存Java虚拟机正在执行的字节码指令的地址，
  如果这个方法就是native的，那PC寄存器的值是undefined。
  PC寄存器的容器至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。
#### 2.5.2 Java虚拟机栈
  每一条Java虚拟机 **线程都有自己私有** 的Java虚拟机栈，这个栈与线程同时创建，用于存储 **栈帧**。
  用于存储局部变量与一些尚未计算好的结果。
  另外，它在方法调用和返回也扮演了重要角色。因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配，**Java虚拟机所使用的内存不需要保存是连续的**。
  Java虚拟机规范既允许Java虚拟机栈被实现成固定大小，也允许根据计算动态来扩展和收缩。如果采用固定大小的Java虚拟机栈，那每一个线程Java虚拟机栈容量可以在线程创建的时候独立选定。
  Java虚拟机栈实现当应提供程序员或者最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩Java虚拟机栈来说，则应当提供调节其最大、最小容量的手段。
  Java虚拟机栈可能发生如下异常情况
  如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将会抛出
  StackOverflowError
  如果Java虚拟机可以允许动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个
  OutOfMemoryError

#### 2.5.3 Java堆
  在Java虚拟机中，堆（heap）是可供各个 **线程共享** 的运行时内存区域，也是供所有 **类实例** 和 **数组对象** 分配内存的区域。
  Java堆在虚拟机启动的时候被创建，它存储了被自动内存管理系统（也就是垃圾收集器）所管理的各种对象，这些受管理的对象无需也无法显式地销毁。
  Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。**Java堆所使用的内存不需要保证是连续的**。
  Java堆可能发生如下异常情况
  如果实际所需的堆超过了自动内存管理系统提供的最大容量，那么Java虚拟机将会抛出一个
  OutOfMemoryError
#### 2.5.4 方法区
  方法区是供各个 **线程共享** 的运行时内存区域。
  它存储每一个类的结构信息：运行时常量池，字段和 方法数据、构造函数和普通方法的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法（2.9）
  方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。**方法区所使用的内存不需要保证是连续的**。
  OutOfMemoryError
#### 2.5.5 运行时常量池
  运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，它包括了若干种不同的常量，从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用。
  运行时常量池类似于传统语言中的符号表，不过它存储数据的范围比通常意义上的符号表更为广泛。
  每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。
  OutOfMemoryError
#### 2.5.6 本地方法栈
  Java虚拟机实现可能会使用到传统的栈来支持Native方法(指用Java以外的其他语言编写的方法)的执行，这个栈就是本地方法栈。
  StackOverflowError
  OutOfMemoryError

### 2.6 栈帧
  栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值和异常分派。
  栈帧会随着方法的调用而创建，随着方法的结束而销毁。无论方法是正常完成还是异常完成都算作方法结束。
  栈帧的存储空间由创建它的线程分配再Java虚拟机栈之中，每一个栈帧都有自己的 **本地变量表**、**操作数栈** 和 **指向当前方法所属的类的运行时常量池的引用**.
#### 2.6.1 局部变量表
  
#### 2.6.2 操作数栈
#### 2.6.3 动态链接
#### 2.6.4 方法调用正常完成
#### 2.6.5 方法调用异常完成
