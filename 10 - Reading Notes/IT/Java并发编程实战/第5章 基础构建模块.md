### 5.1 同步容器类

  Vector Hashtable


### 5.2 并发容器

  ConcurrentMap

  CopyOnWriteArrayList

### 5.3 阻塞队列 和 生产者-消费者模式

  BlockingQueue

### 5.4 阻塞方法与中断方法

  **传递InterruptException** 避开这个异常通常是最明智的策略 ———— 只需把 InterruptException 传递给方法的调用者。
    传递的方法包括 根本不捕获该异常，或者捕获该异常，然后在执行某种简单的清理工作后再次抛出这个异常。

  **恢复中断**

### 5.5 同步工具类

  所有的同步工具都包含一些 **特定的结构化属性**：它们封装了一些状态，这些状态将 **决定** 执行同步工具类的 **线程** 是 **继续执行还是等待**，此外还提供了一些方法对状态进行操作，以及一些方法用于高效地等待同步工具类 **进入预期状态**。

#### 5.5.1 闭锁(Latch)
  闭锁是一种同步工具类，可以延迟线程的进度直到其达到终止状态。
  闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁到达结束状态后，将不会再改变状态，因此这扇门会永远保持打开状态。**闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。**

  **CountDownLatch**

#### 5.5.2 FutureTask

  FutureTask 也可用作闭锁

#### 5.5.3 信号量(Semaphore)

  计数信号量（Counting Semaphore） 用来 **控制** **同时访问** 某个 **特定资源** 的 **操作数量** ，或者 **同时执行** 某个 **指定操作的数量**【CPJ 3.4.1】。计数信号量还可以用来实现某种 **资源池** ，或者对容器 **施加边界**

  Semaphore

#### 5.5.4 栅栏(Barrier)

  栅栏类似于闭锁，它能 **阻塞一组线程直到某个事件发生**。
  栅栏与闭锁的关键区别在于 所有线程必须同时到达栅栏位置，才能继续执行，。闭锁用于等待事件，而栅栏用于等待其他线程。
  栅栏用于实现一些协议。

  **CyclicBarrier**

### 5.6 构建高效且可伸缩的结果缓存

  ConcurrentHashMap
