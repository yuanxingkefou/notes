### 7.1 **任务取消**

#### 7.1.1 中断

  Thread
    interrupt()     方法能中断目标线程
    isInterrupted() 方法能返回目标线程的中断状态。
    静态的inInterrupted() 方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。

    **中断的理解**：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。

    wait、sleep、join等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。
    设计良好的方法 可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。


#### 7.1.2 中断策略

  由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。

#### 7.1.3 中断响应

  当调用可中断的阻塞函数时，例如 Thread.sleep或BlockingQueue.put等，有两种使用策略可用以处理InterruptException:
  1. 传递异常
    传递InterruptException与将InterruptException添加到throws子句中一样容易
  2. 恢复中断状态
    Thread.currentThread().interrupt();

#### 7.1.4 示例：计时运行

#### 7.1.5 通过Future来实现取消

#### 7.1.6 处理不可中断的阻塞

#### 7.1.7 采用newTaskFor来封装非标准的取消

### 7.2 **停止基于线程的服务**

#### 7.2.1 示例：日志服务

#### 7.2.2 关闭ExecutorService
  shutdown()    正常关闭
  shutdownNow() 强行关闭

#### 7.2.3 “毒丸” 对象

#### 7.2.4 示例：只执行一次的服务

#### 7.2.5 shutdownNow的局限性

### 7.3 **处理非正常的线程中止**

    未捕获异常的处理

### 7.4 **JVM的关闭**

#### 7.4.1 关闭钩子

  关闭钩子是指通过Runtime.addShutdownHook注册的但尚未开始的线程。

#### 7.4.1 守护线程

#### 7.4.3 终结器
