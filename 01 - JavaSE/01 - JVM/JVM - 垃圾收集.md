## 对象存活判断

1. 引用计数法：缺点是无法处理循环引用问题

2. 可达性分析

  虚拟机栈（栈帧中的本地变量表）中引用的对象
  方法区中类静态属性引用的对象
  方法区中常量引用的对象
  本地方法栈JNI(Native方法)中引用的对象

## 垃圾收集算法

1. `标记-清除` (老年代)
  标记所有从根结点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存
2. `复制` (新生代)
  将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于`新生代`(存活对象少，垃圾对象多)
3. `标记-整理` (老年代)
  标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。
4. `分代收集`
  当前商业虚拟机的垃圾收集都采用分代收集。没有新的思想
  **新生代** 中每次垃圾收集时都发现有大批对象死去，只有少量存活，选用 **复制算法**
  **老年代** 中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用 **标记-清理** **标记-整理** 算法进行回收

`MinorGC` 从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。
`Major GC`是清理老年代。
`Full GC` 是清理整个堆空间—包括年轻代和老年代。

### Minor GC触发条件
  当Eden区满时，触发Minor GC。

### Full GC触发的条件
 (1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

  1，新生代：
    （1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。
    （2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。
  2，老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。
  3，持久代：持久代如果满了，将触发Full GC。
