### 类 修饰符

`Public`可以从其他类中访问,默认为统一包下的任意类。
`Abstract` `抽象类`，不能被实例化，可以包含抽象方法，抽象方法没有被实现，无具体功能，只能衍生子类。
`Final`不能再声明子类,不能被继承

### 构造函数修饰符  

`Public`可以从所有的类中访问
`Protected`只能从自己的类和它的子类中访问
`Private`只能在本类中访问

### 域/成员变量修饰符  

一个类的成员变量的声明必须在类体中，而不能在方法中，方法中声明的是局部变量。

`Static` `类变量`对该类的所有实例只能有一个域值存在,一个类所拥有的变量，不是类的每个实例有的变量。类变量是指不管类创建了多少对象，系统仅在第一次调用类的时候为类变量分配内存，所有对象共享该类的类变量，因此可以通过类本身或者某个对象来访问类变量。
`实例变量`：和类变量对应，即每个对象都拥有各自独立的实例变量。

`Public`可以从所有的类中访问
`Protected`只能从本类和它的子类中访问
`Private`只能从本类中访问它

`transient`不是一个对象持久状态的一部份,对象串化的时侯并不会将所赋值的值保存到传中，串化的对象从磁盘读取出来仍然是null。
`Volatile`可以被异步的线程所修改,声明一个可能同时被并存运行的几个线程所控制和修改的变量。
`final` `常量`必须对它赋予初值并且不能修改它
类成员的访问控制符：

即类的方法和成员变量的访问控制符，一个类作为整体对象不可见，并不代表他的所有域和方法也对程序其他部分不可见，需要有他们的访问修饰符判断。

权限如下：
访问修饰符同一个类同包不同包，子类不同包，非子类
private√
默认√√
protected√√√
public√√√√
### 局部变量 修饰符

`final`必须对它赋予初值并且不能修改它

### 方法修饰符 和变量对象分为实例方法和类方法，并用有无static修饰区别

`static` `类方法`被绑定于类本身而不是类的实例.使用static关键字说明的方法
  1. 第一次调用含类方法的类是，系统只为该类创建一个版本，这个版本被该类和该类的所有实例共享。
  2. 类方法只能操作类变量，不能访问实例变量。类方法可以在类中被调用，不必创建实例
  类方法：静态方法，用static修饰，
  1. 调用时，使用类名作为前缀，而不是类的某个实例对象名
  2. 不能被单独对象拥有，属于整个类共享。
  3. 不能处理成员变量。
`实例方法`：实例方法可以对当前对象的实例变量操作，而且可以访问类变量。
  方法可以重载，要求：方法名相同，但是参数必须有区别。（参数不同可以使类型不同，顺序不同，个数不同）
  方法的返回类型：若无返回类型，则声明为void.
  方法中的变量作用域：
  1. 成员变量：整个类。
  2. 局部变量：定义起到方法块结束为止。
  3. 方法参数：整个方法或者构造方法。
  4. 异常处理参数：参数传递给异常处理方法。
`Public`可以从所有的类中访问它
`Protected`只能从本类及其子类中访问它
`Private`只能从本类中访问它
`abstract`没有方法体，属于一个抽象类
`抽象方法`：用abstract修饰，只有声明部分，方法体为空，具体在子类中完成。

`native`该方法由其他编程语言实现
``本地方法``：用native修饰的方法，表示用其他语言书写的特殊方法，包括C，C++，FORTRAN，汇编语言等。
`asnchronized`在一个线程调用它之前必须先给它加
`final`子类不能覆盖它
`最终方法`：用final修饰，不能被子类重新定义的方法。

`构造方法`:和类同名的方法。为新建对象开辟内存空间后，用于初始化新建的对象。不能用对象显式的调用。

`静态初始化器`：格式：static{<赋值语句组>}

静态初始化器与构造方法的区别：
静态初始化器
  对类的静态域初始化
  类进入内存后，系统调用执行
  属特殊语句（仅执行一次）
构造方法
  对新建的对象初始化
  执行new后自动执行
  属特殊方法
