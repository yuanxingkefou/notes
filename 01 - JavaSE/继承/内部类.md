在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。
广泛意义上的内部类一般来说包括这三种：成员内部类（静态内部类、非静态内部类）、局部内部类、匿名内部类，

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。

```java
public class InnerClassTest {
	public static void main(String[] args) {
		/*
		 * 创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()
		 * 创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()
		 */
		// 初始化Bean1
		InnerClassTest t = new InnerClassTest();
		InnerClassTest.Bean1 b1 = t.new Bean1();
		b1.I++;
		// 初始化Bean2
		InnerClassTest.Bean2 b2 = new InnerClassTest.Bean2();
		b2.J++;
		// 初始化Bean3
		Bean b = new Bean();
		Bean.Bean3 b3 = b.new Bean3();
		b3.k++;
	}
	class Bean1 {
		public int I = 0;
	}
	static class Bean2 {
		public int J = 0;
	}

}
class Bean {
	class Bean3 {
		public int k = 0;
	}
}
```
创建静态内部类对象的一般形式为：  **外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()**

创建成员内部类对象的一般形式为：  **外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()**


###  变量

```java
/要求：使用已知的变量，在控制台输出30，20，10。
　class Outer {
    public int num = 10;
    class Inner {
        public int num = 20;
        public void show() {
            int num = 30;
            System.out.println(?);
            System.out.println(??);
            System.out.println(???);
        }
    }
}

class InnerClassTest {
    public static void main(String[] args) {
        Outer.Inner oi = new Outer().new Inner();
        oi.show();
    }    
}
```
1、局部变量 2、this，和3、Outer.this，也就是内部类访问外部类属性方法的原理。这考察三个东西，

1、在一个方法中，使用直接使用变量名，肯定使用的是局部变量，因为会把大的成员变量给隐藏掉，这题中，也就是说show方法中的num会将内部类中的成员变量num隐藏掉，而内部类中的成员变量num又会把外部类中的成员变量num隐藏掉，所以通过直接输出num，会是show方法中的局部变量的值30.   

2、使用this.num调用，其this代表的是调用该方法的对象，调用show方法的是oi，oi也就是内部类对象，所以oi.num也就标识内部类的成员变量num的值20

3、Outer.this.num，调用的外部类中的成员变量num的值也就是10，这个如果不清楚就看上面总结中的第二点，就是那个原理。


### 为什么内部类调用的外部变量必须是final修饰的？

因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，final保证这个变量始终指向一个对象。首先，内部类和外部类其实是处于同一个级别，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。
为了解决：局部变量的生命周期与局部内部类的对象的生命周期的不一致性问题
